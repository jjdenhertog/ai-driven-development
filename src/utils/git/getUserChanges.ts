/* eslint-disable max-depth */
import { execSync } from 'node:child_process';
import { log } from '../logger';
import { getMainBranch } from './getMainBranch';

export type CommitInfo = {
    hash: string;
    author: string;
    date: string;
    message: string;
};

export type FileChange = {
    file: string;
    diff: string;
};

export type UserChanges = {
    taskId: string;
    branch: string;
    commits: CommitInfo[];
    fileChanges: FileChange[];
    analyzedAt: string;
};

// Comprehensive list of patterns to detect AI-generated commits
export const AI_COMMIT_PATTERNS = [
    '(AI-generated)',
    'AI-generated',
    'Generated by AI',
    'AI commit',
    'Automated commit',
    'Bot commit',
    'Auto-generated',
    'Automatically generated',
    'Generated with Claude',
    'Generated by Claude',
    'Generated with ChatGPT',
    'Generated by ChatGPT',
    'Generated with Copilot',
    'Generated by Copilot',
    'Co-Authored-By: Claude',
    'Co-Authored-By: GitHub Copilot',
    'Co-Authored-By: dependabot',
    'ðŸ¤–',
    '[bot]',
    '[automated]',
    '[auto]',
    'dependabot',
    'feat(setup)',
    'github-actions[bot]',
    'renovate[bot]',
    'ready for review',
    'semantic-release-bot',
    'greenkeeper[bot]'
];

// Check if a commit is AI-generated based on message and author
function isAIGeneratedCommit(message: string, author: string): boolean {
    const lowerMessage = message.toLowerCase();
    const lowerAuthor = author.toLowerCase();
    
    return AI_COMMIT_PATTERNS.some(pattern => {
        const lowerPattern = pattern.toLowerCase();

        return lowerMessage.includes(lowerPattern) || lowerAuthor.includes(lowerPattern);
    });
}

// Safely escape shell arguments to prevent injection
function escapeShellArg(arg: string): string {
    return `'${arg.replace(/'/g, String.raw`'\''`)}'`;
}

/**
 * Get user changes from a merged PR by finding the merge commit and analyzing its contents
 * This works even if the branch has been deleted after merging
 */
export function getUserChanges(branch: string, taskId: string): UserChanges | null {
    try {
        const mainBranch = getMainBranch();
        
        const safeMainBranch = escapeShellArg(mainBranch);
        
        // Find the merge commit for this branch/task
        log(`Looking for merge commit for branch ${branch} or task ${taskId}...`, 'info');
        
        // Try different patterns to find the merge commit
        const searchPatterns = [
            `--grep="Merge.*${branch}"`,
            `--grep="Merge.*${taskId}"`,
            `--grep="\\[${taskId}\\]"`,
            `--grep="task ${taskId}"`,
            `--grep="#${taskId}"`  // GitHub PR numbers
        ];

        let mergeCommit = '';
        
        for (const pattern of searchPatterns) {
            try {
                const result = execSync(
                    `git log ${pattern} --merges --pretty=format:"%H" -n 1 ${safeMainBranch}`,
                    { encoding: 'utf8' }
                ).trim();
                
                if (result) {
                    mergeCommit = result;
                    break;
                }
            } catch {
                // Continue trying other patterns
            }
        }

        if (!mergeCommit) {
            log(`No merge commit found for branch ${branch} or task ${taskId}`, 'warn');

            return null;
        }

        log(`Found merge commit: ${mergeCommit}`, 'info');
        const safeMergeCommit = escapeShellArg(mergeCommit);

        // Get all commits that were part of this merge
        // This shows us all commits between the merge base and the second parent (the feature branch)
        const mergeBase = execSync(
            `git merge-base ${safeMergeCommit}^1 ${safeMergeCommit}^2 2>/dev/null || echo ""`,
            { encoding: 'utf8' }
        ).trim();

        if (!mergeBase) {
            log('Could not determine merge base', 'warn');

            return null;
        }

        const safeMergeBase = escapeShellArg(mergeBase);
        
        // Get all commits from the feature branch (second parent of merge)
        const commitsOutput = execSync(
            `git log ${safeMergeBase}..${safeMergeCommit}^2 --pretty=format:"%H|%an|%ad|%s" --date=iso-strict`,
            { encoding: 'utf8' }
        ).trim();

        if (!commitsOutput) {
            log('No commits found in merged branch', 'info');

            return null;
        }

        const commits: CommitInfo[] = [];
        const userCommits: string[] = [];

        // Parse commits and filter out AI-generated ones
        commitsOutput.split('\n').forEach(line => {
            const [hash, author, date, message] = line.split('|');
            const commitInfo: CommitInfo = { hash, author, date, message };
            

            // Identify user commits (not AI-generated)
            if (!isAIGeneratedCommit(message, author)) {
                commits.push(commitInfo);
                userCommits.push(hash);
            }
        });

        log(`Found ${userCommits.length} user commits out of ${commits.length} total commits`, 'info');

        if (userCommits.length === 0) {
            log(`No user commits found for task ${taskId}`, 'info');
            
            return {
                taskId,
                branch,
                commits,
                fileChanges: [],
                analyzedAt: new Date().toISOString()
            };
        }

        // Get unique file changes from user commits
        const fileChangesMap = new Map<string, string>();
        
        for (const commitHash of userCommits) {
            const safeHash = escapeShellArg(commitHash);
            
            // Get files changed in this commit
            const filesOutput = execSync(
                `git diff-tree --no-commit-id --name-only -r ${safeHash}`,
                { encoding: 'utf8' }
            ).trim();

            if (filesOutput) {
                const files = filesOutput.split('\n');
                
                for (const file of files) {
                    const safeFile = escapeShellArg(file);
                    
                    try {
                        // Get the cumulative diff for this file across all user commits
                        // Compare the file at merge base with the file at the last user commit
                        const lastUserCommit = userCommits.at(-1);
                        if (!lastUserCommit) {
                            continue;
                        }
                        
                        const safeLastCommit = escapeShellArg(lastUserCommit);
                        
                        const diff = execSync(
                            `git diff ${safeMergeBase}..${safeLastCommit} -- ${safeFile}`,
                            { encoding: 'utf8', maxBuffer: 1024 * 1024 * 10 }
                        );
                        
                        if (diff) {
                            fileChangesMap.set(file, diff);
                        }
                    } catch (error) {
                        log(`Failed to get diff for file ${file}: ${String(error)}`, 'warn');
                    }
                }
            }
        }
        
        // Convert map to array
        const fileChanges: FileChange[] = Array.from(fileChangesMap.entries()).map(([file, diff]) => ({
            file,
            diff
        }));

        log(`Analyzed ${fileChanges.length} files with user changes`, 'info');

        return {
            taskId,
            branch,
            commits,
            fileChanges,
            analyzedAt: new Date().toISOString()
        };

    } catch (error) {
        log(`Failed to analyze merged PR: ${String(error)}`, 'error');
        
        return null;
    }
}